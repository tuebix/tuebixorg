#!/usr/bin/env python3
desc = """
A tool used to validate the transition from Jekyll to Hugo.

To use it, check out the revisions 9f71b7dd25ab5943862088a1f3ef6af2e6679f65 and 02b7f69d53088defb59b127dbc3a8b7b186aee3b in two seperate worktrees. Run hugo in the new revision and jekyll in the old revision to generate the `hugo/public` and `_site` directories.
Then run this script in the worktree of the new revision and pass the path of the worktree of the old revision as `old-worktree`.

It will then show you the difference in the output Jekyll generated and the output Hugo generates, and you can judge if these differences are ok.
"""
from pathlib import Path
import sys
import tempfile
import shutil
import subprocess
import re
import argparse

CSP_DOKU = """<!-- CSP documentation:
    - Embedded asciinema (multiple pages): Requires script+frame
    - Embedded OpenStreetMap (anfahrt.md): Requires img+frame (img via data:)
    - lageplan.md: Requires object (application/pdf)
    - kinder.md: Requires img
    - frame-ancestors 'self'; Might be nice to have but not allowed in <meta>
  -->"""


def main(args):
    repodir = Path(__file__).parent.parent.resolve()
    hugo_build_dir = repodir / "hugo" / "public"
    jekyll_build_dir = Path(args.old_worktree) / "_site"

    for fp in hugo_build_dir.rglob("**/*"):
        rp = fp.relative_to(hugo_build_dir)
        if not (jekyll_build_dir / rp).exists():
            print(f"only generated by hugo: {rp}")

    for fp in jekyll_build_dir.rglob("**/*"):
        rp = fp.relative_to(jekyll_build_dir)
        if not (hugo_build_dir / rp).exists():
            print(f"only generated by jekyll: {rp}")

    for fp in hugo_build_dir.rglob("**/*"):
        if fp.is_dir():
            continue
        rp = fp.relative_to(hugo_build_dir)
        if not (jekyll_build_dir / rp).exists():
            continue
        assert not (hugo_build_dir / rp).is_symlink()
        assert not (jekyll_build_dir / rp).is_symlink()
        if (hugo_build_dir / rp).read_bytes() == (jekyll_build_dir / rp).read_bytes():
            continue
        suffix = "_" + str(rp).replace("/", "_")
        with tempfile.NamedTemporaryFile(suffix="hugo_" + suffix) as tf1:
            shutil.copy(hugo_build_dir / rp, tf1.name)
            with tempfile.NamedTemporaryFile(suffix="jekyll_" + suffix) as tf2:
                shutil.copy(jekyll_build_dir / rp, tf2.name)
                if rp.suffix == ".html":
                    content = (
                        Path(tf2.name)
                        .read_text()
                        .replace('href="http://localhost:4000/', 'href="/')
                    )

                    ignored_in_jekyll_output = [
                        re.escape(CSP_DOKU),
                        re.escape('<meta name="description" content="">'),
                        re.escape('<!--<a class="site-title" href="/">Tübix</a>-->'),
                        re.escape('<!-- <h2 class="footer-heading">Tübix</h2> -->'),
                        r'class=\s*"language-plaintext highlighter-rouge"',
                    ]
                    if rp.parts[-1] == "index.html":
                        if str(rp.parent) == ".":
                            link = "/"
                        else:
                            link = "/" + str(rp.parent) + "/"
                    else:
                        link = "/" + str(rp)
                    ignored_in_jekyll_output.append(
                        re.escape(f'<link rel="canonical" href="{link}">')
                    )

                    for ignored in ignored_in_jekyll_output:
                        content = re.sub(ignored, "", content)

                    content = re.sub(
                        r'<div\s*>\s*<div class="highlight">\s*<pre class="highlight">(((?!<\/pre).)*)</pre>\s*<\/div>\s*<\/div>',
                        r'<pre tabindex="0">\g<1></pre>',
                        content,
                        flags=re.DOTALL,
                    )

                    content = re.sub(
                        r'<div\s*>\s*<div class="highlight">(((?!<\/pre).)*)</pre>\s*<\/div>\s*<\/div>',
                        r"\g<1></pre>",
                        content,
                        flags=re.DOTALL,
                    )

                    Path(tf2.name).write_text(content)

                    Path(tf1.name).write_text(Path(tf1.name).read_text())

                subprocess.run(
                    ["tidy", "-modify", tf1.name, tf2.name],
                    stderr=subprocess.DEVNULL,
                )
                if Path(tf1.name).read_bytes() == Path(tf2.name).read_bytes():
                    continue
                print(f"Shown in meld: {rp}")
                subprocess.check_call(["meld", tf1.name, tf2.name])


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=desc,
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "old_worktree",
        metavar="old-worktree",
        help="Path to a worktree of revision 02b7f69d53088defb59b127dbc3a8b7b186aee3b",
    )
    args = parser.parse_args()
    main(args)
